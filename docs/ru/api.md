# Документция для DeskChan API

Все взаимодействия между плагинами происходят
с помощью сообщений. Любое сообщение имеет тег
и данные (данные могут быть равны null, если они не нужны).

На каждое сообщение могут быть подписаны ноль или несколько
плагинов. Каждый подписанный на тег плагин получает
все сообщения, которые отправлены с этим тегом.

Если требуется выбор из нескольких альтернативных
реализаций (то есть сообщение должен получить один плагин,
а не все сразу), то рекомендуется использовать механизм
"альтернатив" (см. core:register-alternative).

Рекомендуется ограничиться следующими типами данных
для сообщения: String, Integer, Float, Double,
Map<String, Object>, List<Object>. При этом последние
два типа должны содержать только объекты вышеперечисленных
типов.

В редких случаях возможно применение других типов.

Это необходимо для того, чтобы любое сообщение могло
быть сериализовано и десериализовано в JSON.

Для экспериментов возможно использовать вкладку
Debug (Отладка) диалога настроек DeskChan. В верхнем
поле ввода можно указать тег сообщения, а в нижнем -
данные в формате JSON. При нажатии кнопки сообщение
будет отправлено от имени плагина gui.

## Уведомления от плагина core

### core-events:plugin-load

#### Данные (String)

    id плагина

#### Описание

Посылается ядром каждый раз, когда загружается новый
плагин.

Это не обычное сообщение. При подписке на него подписчику
сразу же будут присланы сообщения на каждый уже загруженный
плагин. Таким образом вы можете узнать начальный список
плагинов.

### core-events:plugin-unload

#### Данные: String

    id плагина

#### Описание

Посылается ядром каждый раз, когда выгружается какой-нибудь
плагин.

## Сообщения для плагина core

### core:quit

#### Данные: null

#### Описание

Инициирует завершение приложения. Все плагины будут
выгружены. Отменить завершение приложения штатными
средствами нельзя.

### core:register-alternative

#### Данные: Map<String, Object>

    srcTag: String
    dstTag: String
    priority: Integer

#### Описание

Регистрирует новую альтернативу dstTag для тега
srcTag с приоритетом priority. Плагин core подписывается
на srcTag. При поступлении сообщения оно будет
перенаправлено на srcTag (при этом отправитель останется
таким как был, а не изменится на core). Если существует
несколько альтернатив для srcTag, то будет выбрана та,
которая имеет наибольшее числовое значение приоритета.

Плагин core запоминает id плагина, который зарегистрировал
альтернативу. При его выгрузке все альтернативы, которые
он зарегистрировал, будут удалены.

Для регистрации нескольких альтернатив можно воспользоваться
сообщением с тегом core:register-alternative**s**. Оно
принимает те же данные, но обёрнутые в список
(List<Map<String, Object>>).

### core:unregister-alternative

#### Данные: Map<String, Object>

    srcTag: String
    dstTag: String

#### Описание

Удаление альтернативы dstTag для тега srcTag. Альтернатива
будет удалена только если данное сообщение отправлено
тем же плагином, что и зарегистрировал данную альтернативу.

См. также: core:register-alternative.

### core:change-alternative-priority

#### Данные: Map<String, Object>

    srcTag: String
    dstTag: String
    priority: Integer

#### Описание

Изменяет числовое значение приоритета для альтернативы
dstTag для тега srcTag. Изменить приоритет альтернативы
может любой плагин, а не только тот, который её
зарегистрировал.

В нормальных условиях изменять приоритет альтернативы
следует только по запросу пользователя.

См. также: core:register-alternative

### core:query-alternatives-map

#### Данные: Map<String, Object>

    seq: Object (рекомендуется Integer)

#### Ответное сообщение: Map<String, Object>

    seq: Object
    map:  Map<String, Object>
        Ключи: srcTag
        Значения: Map<String, Object>
            tag: String (dstTag)
            priority: Integer
            plugin: String (id плагина)

#### Описание

Служит для запроса списка всех зарегистрированных
альтернатив. Полезно для предоставления пользователю
возможности настройки приоритетов.

Тег ответного сообщения соответствует идентификатору
плагина, пославшего запрос. seq в ответном сообщении
равен seq в запросе.

См. также: core:register-alternative

### core:get-plugin-data-dir

#### Данные: Map<String, Object>

    seq: Object (рекомендуется Integer)

#### Ответное сообщение: Map<String, Object>

    seq: Object
    path: String
    
#### Описание

Позволяет плагину получить путь к каталогу, который
ему рекомендуется использовать для сохранения
своих настроек.

Тег ответного сообщения соответствует идентификатору
плагина, пославшего запрос. seq в ответном сообщении
равен seq в запросе.

### core:create-pipe

#### Данные (String)

    Тег пайпа

#### Описание

Создаёт пайп (конвейер) с указанным именем (тегом).
После этого ядро подписывается на указанный тег
и реализует некоторую логику. А именно:

Пайп содержит в себе последовательность тегов
сообщений, слушатели которых по сути дела являются
обработчиками пайпа. При приходе сообщения на тег
пайпа, его данные будут по очереди отправлены
на каждый тег, который составляет конвейер. При этом
действует следующее соглашение: данные проходящие
через пайп обязательно имеют тип Map<String, Object>
(если отправить на пайп данные другого типа, то
они будут преобразованы в Map с ключом "data" равным
исходному значению), этот Map содержит ключ "seq",
который никто не должен изменять кроме плагина core.
Каждый обработчик конвейера должен отправлять данные
снова в конвейер (на тот же тег), при этом допустимо
изменять все ключи кроме "seq".
Когда весь конвейер пройден, итоговые данные
отправляются в сообщении с тегом равным
идентификатору плагина, который отправил сообщение
в пайп.

### core:destroy-pipe

#### Данные (String)

    Тег пайпа

#### Описание

Уничтожает указанный пайп. Пайп должен быть создан
тем же плагином, что и уничтожает его. При выгрузке
плагина все созданные им пайпы уничтожаются
автоматически.

### core:append-pipe-stage

#### Данные (Map<String, Object>)

    pipe: String
    tag: String

#### Описание

Добавляет тег tag в конец конвейера pipe.
Теперь вы обязаны слушать тег tag и пересылать
данные каждого сообщения с тегом pipe. При этом
данные всегда имеют тип Map<String, Object> и вы можете
менять любые его ключи кроме seq и pipeReplyTo.

### core:prepend-pipe-stage

#### Данные (Map<String, Object>)

    pipe: String
    tag: String
    
#### Описание
    
Добавляет тег tag в начало конвейера pipe.
Требования те же, что и для core:append-pipe-stage.

### core:remove-pipe-stage

#### Данные (Map<String, Object>)

    pipe: String
    tag: String

#### Описание

Удаляет тег tag из конвейера pipe. Теперь вы не
обязаны слушать тег tag. Также теги автоматически
удаляются из конвейера при выгрузке плагина,
который их добавил. Удалить тег из конвейера может
только тот плагин, который его туда добавил.

## Уведомления от плагина gui

### gui-events:character-left-click

Пользователь кликнул левой кнопкой мыши по персонажу

### gui-events:character-right-click

Пользователь кликнул правой кнопкой мыши по персонажу

### gui-events:character-middle-click

Пользователь кликнул средней кнопкой мыши по персонажу

### gui-events:character-double-click

Пользователь дважды кликнул по персонажу

### gui-events:balloon-left-click

Пользователь кликнул по сообщению левой кнопкой мыши

### gui-events:balloon-right-click

Пользователь кликнул по сообщению правой кнопкой мыши

### gui-events:balloon-middle-click

Пользователь кликнул по сообщению средней кнопкой мыши

### gui-events:balloon-double-click

Пользователь дважды кликнул по сообщению кнопкой мыши

## Сообщения плагину gui

### gui:say

#### Данные: Map<String, Object>

    text: String
    characterImage: String (опционально)
    timeout: Integer (опционально)
    priority: Integer (опционально)

#### Описание

Вывести текстовое сообщение. При этом на время показа
сообщения может быть изменена картинка персонажа на
указанную (из скина, если текущий скин не содержит
данного изображения, будет использовано normal).

Сообщение будет закрыто по клику пользователя или
по таймауту (указывается в миллисекундах, нулевое
значение отключает автоматическое закрытие сообщения,
при отсутствии значения будет использоваться
значение по умолчанию, которое можно настраивать
пользователь).

При закрытии сообщения картинка персонажа изменится на
текущую.

Для сообщения можно задать приоритет. По умолчанию он
равен 1000. Каждое сообщение висит как минимум половину
своего таймаута. Если посылается запрос на отображение
сообщения, когда уже висит "облачко" с другим,
то программа руководствуется следующими правилами:
- если приоритет нового сообщения больше, чем предыдущего,
то через половину таймаута старого новое отображается
сразу поверх старого;
- если приоритет равен или ниже, то сообщение будет
отображено после полного таймаута предыдущего и всех
остальных более приоритетных сообщений в очереди;
- если приоритет равен нулю или меньше, то сообщение
считается неважным и не будет запланировано к отображению
вообще.

Рекомендуется вместо прямого обращения к плагину gui
использовать альтернативу DeskChan:say.

### gui:set-image

#### Данные: String

    Название картинки

#### Описание

Изменить текущую картинку персонажа. Используется,
если никакое сообщение не отображается, либо текущее
сообщение не переопределяет картинку.

Если картинка с таким именем не содержится в текущем скине,
то используется normal.

### gui:change-skin

#### Данные: String или Path

    Путь к скину

#### Описание

Меняет текущий скин. Изменение будет сохранено
в настройках.

### gui:register-simple-action

#### Данные: Map<String, Object>

    name: String
    msgTag: String
    msgData: Object (опционально)

#### Описание

Регистрирует простое действие. Оно доступно через
контекстное меню персонажа. При выборе действия
будет послано сообщение с тегом msgTag и msgData
(null, если не указать).

Действия автоматически удавляются при выгрузке плагина,
который их зарегистрировал.

В будущем способ вызова простого действия пользователем
может быть изменён.

Рекомендуется не обращаться напрямую к плагину gui,
а использовать альтернативу
DeskChan:register-simple-action.

Для регистрации нескольких действий рекомендуется использовать
сообщение с тегом DeskChan:register-simple-action**s**. В
качестве данных оно принимает список таких же наборов
параметров (List<Map<String, Object>>).

### gui:show-notification

#### Данные: Map<String, Object>

    name: String
    text: String

Показывает окно сообщения с названием name и текстом text.

### gui:setup-options-tab

#### Данные: Map<String, Object>

    name: String
    msgTag: String (опционально)
    controls: List<Map<String, Object>>
    
#### Описание

Создаёт или обновляет уже существующую вкладку 
настроек для плагина, отправившего это сообщение
(автоматически удаляется при его выгрузке).

Если указан параметр msgTag, то на вкладку будет
добавлена кнопка "Сохранить", которая при нажатии
отправляет сообщение с указанным тегом и со значениями
элементов управления.

controls является списком элементов управления,
которые должны быть размещены на вкладке.

Каждый элемент управления имеет как минимум три параметра:

    type: String
    id: String (опционально)
    label: String (опционально)

type задаёт тип элемента управления (в зависимости от него
могут добавлять другие обязательные и опциональные
параметры), label позволяет разместить текстовую подпись
рядом с элементом управления. Если же у элемента задан id,
то при нажатии на кнопку сохранения, он будет добавлен
в Map, который будет отправлен в качестве данных
сообщения (при этом ключом будет id, а значением -
текущее значение элемента управления).

#### Доступные элементы управления

##### Label

    value: String

Самый простой элемент управления. Статичная надпись.

##### TextField

    value: String (опционально)
    hideText: Boolean (опционально)

Однострочное текстовое поле.

##### Spinner

    value: Integer (опционально)
    min: Integer (опционально)
    max: Integer (опционально)
    step: Integer (опционально)

Поле ввода для числовых значений.

##### ComboBox

    values: List<String>
    value: Integer (опционально)

Поле выбора из фиксированного набора вариантов.
Значением поля является индекс выбранного элемента.

##### ListBox

    values: List<String>
    value: List<Integer>

Поле выбора из фиксированного набора вариантов.
При этом пользователь имеет возможность выбрать
несколько элементов сразу. Значением является
список индексов выбранных элементов.

##### Button

    value: String
    msgTag: String
    msgData: Object (опционально)

Кнопка. Посылает сообщение с тегом msgTag и данными
msgData при нажатии.

##### FileField

    value: String
    initialDirectory: String

Поле выбора файла. Можно указать начальную директорию.

##### DatePicker

    value: String (опционально)
    format: String (опционально)
    
Поле для выбора даты.  
Несмотря на то, что значение в поле отображается в
зависимости от локали, по умолчанию его следует задавать
и получать в формате ISO (например, 2017-04-09). Формат
можно изменить с помощью параметра format. Например
для РФ (9.04.2017), это будет `d.M.y`.

## Система характеров (говорилка)

### talk:request

#### Данные: Map<String, Object>

    purpose: String (опционально)

#### Описание

Выбирает из списка доступных подходящих фраз одну с заданным
назначением, компонует её и отправляет в DeskChan:say.
Список назначений можно посмотреть в описании системы
характеров.

### talk:make-influence

#### Данные: Map<String, Object>

    type: String, возможные значения - character, emotional
    feature: String
    multiplier: Float

#### Описание

Оказывает влияние на характер (в случае type=character) или
на эмоциональное состояние (в случае type=emotional).
Значение feature указывает, на какую компоненту системы
оказывается влияние. В случае type=character стандартное
значение - sympathy, В случае type=emotional стандартное
значение - happiness, полный список можно посмотреть
в описании системы характеров.
multiplier - число, на которое сдвигается шкала.

### talk:register-perk

#### Данные: Map<String, Object>

    priority: Integer

#### Описание

Сохраняет плагин, отправивший сообщение, как перк, к которому
впоследствие будут отсылаться запросы с целью его внедрения
в систему характеров. 
На данный момент перки могут только редактировать текст сообщения
перед посылкой его в очередь на отображение. Перки получают
ообщения в зависимости от приоритета, указанного при регистрации,
от самого большего к самому меньшему.

### talk:unregister-perk

#### Описание

Удаляет плагин из списка перков.

### talk:create-quotes-base

#### Данные: Map<String, Object>

    url: String
    filename: String

#### Описание

Обращается к JSON файлу фраз по указанной в url ссылке и 
сохраняет его в качестве списка фраз в формате xml
под названием filename.quotes.

### talk:perk-answer

#### Данные: Map<String, Object>

    url: String
    filename: String

#### Описание

На этот тип сообщений плагины должны присылать ответы
на запросы, присланные им от talking_system.
Подробнее не будет, лезьте в код, конкретно файл PerkContainer.java.

## Уведомления от плагина talking_system

### perk:operate

Запросы к перкам от talking_system.
Подробнее не будет, лезьте в код, конкретно файл PerkContainer.java.


## Groovy Plugin API

Рекомендуется писать плагины на языке программирования
Groovy. Плагином является каталог, содержащий файл
plugin.groovy. В этом же каталоге можно также
сохранить какие-либо статичные файлы, необходимые
плагину. Для хранения настроек и кеша следует
использовать другой каталог (см. core:get-plugin-data-dir).

Скрипт должен отправить все необходимые сообщения
и подписаться на все необходимые ему сообщения.

Помимо всех стандартных функций Java ему доступны следующие
функции DeskChan Plugin API:

    void sendMessage(String tag, Object data);
    void sendMessage(String tag, Object data, ResponseListener responseListener);
    void addMessageListener(String tag, MessageListener listener);
    void removeMessageListener(String tag, MessageListener listener);
    void addCleanupHandler(Runnable handler);

sendMessage позволяет отправить сообщение с тегом tag
и данными data. Версия с тремя аргументами
преобразует data в Map, если он им не является
(при этом прошлое значение data будет сохранено
с ключом "data"). В этот словарь будет добавлено
числовое поле seq, которое будет монотонно возврастать
с каждым вызовом данной функции (то есть его можно
считать уникальным первые несколько миллиардов
вызовов sendMessage). В качестве последнего аргумента
можно передать лямбда-функцию, которая будет вызвана,
когда будет получен ответ с тем же seq и с тегом
соответствующим id текущего плагина. Лямбда-функция
должна принимать два аргумента: sender (String) и
data (Object).

addMessageListener и removeMessageListener соответственно
добавляют и удаляют подписку на сообщение
с указанным тегом (плагин может подписываться несколько
раз на одно и то же сообщения разными слушателями).
Слушателем может выступать лямбда-функция, принимающая
три аргумента: sender (String), tag (String), data (Object).
Можно использовать одного и того же слушателя для
разных сообщений (различать их по аргументу tag, если
требуется). При выгрузке плагина все его слушатели
удаляются автоматически.

addCleanupHandler позволяет зарегистрировать обработчик
выгрузки плагина. Он должен уничтожить те объекты, которые
в ином случае уничтожены не будут. В качестве него может
выступать лямбда-функция без аргументов.

## Python (Jython) Plugin API  

_Данное API не является стандартным, запилено другим человеком и может быть изменено в будущем._  

По сути тут всё аналогично вышеописанному Groovy Plugin API. Обратить внимание нужно на буквально несколько моментов:  

1. В отличие от Groovy-плагинов, Jython-плагины не являются наследниками никаких классов и,
соответственно, не имеют встроенных методов `sendMessage()`, `addMessageListener()` и т. п.
Но в исполяемую среду "инжектится" специальный объект — так называемая *шина* (**bus**) — с помощью
которой плагин "общается" с приложением. Она предоставляет ему описанные в предыдущем разделе методы.  
С версии 1.0.2 плагина *jython_support* для вызова API можно использовать модуль **busproxy**, который не только
позволяет импортировать функции в среду исполнения, но и предоставляет их псевдонимы в более Pythonic-виде
(`send_message()`, `add_message_listener()` и т. д.).  
2. Типы данных на ходу преобразуются между типами одного языка в другой. В случае каких-либо проблем
стоит иметь это в виду. Для примера использования API смотрите приложенный плагин-пример (*test_python*).  
3. Необходимые Вам зависимости (также с версии 1.0.2) можно ставить, используя *pip*, в папку `__dependencies__` внутри
проекта Вашего плагина. Она автоматически добавляется в путь поиска модулей.  
Устанавливать зависимости можно, например, следующей командой:  
`pip install --target=__dependencies__ --ignore-installed <названия пакетов...>`  
4. С версии 1.0.1 для *шины* (а с версии 1.0.2 он есть и в модуле *busproxy*) добавлен нестандартный метод `say()` для
облегчения вывода сообщений. Он автоматически преобразует строку в правильную кодировку и отправит сообщение GUI-плагину
на отображение сообщения. Поэтому при работе с символами, не входящими в таблицу ASCII, строго рекомендуется
использовать именно его! Также не забывайте указывать `u"юникодную природу строки"`!  
С версии 1.1.0 полностью поддерживаются все параметры `gui:say` (priority, timeout...). Для *шины* они указываются
вторым параметром в виде словаря, а для функции из модуля *busproxy* используются keywords-аргументы.  
5. Сначала плагин поддерживал интерпретацию только Python 2.5, но с версии 1.0.2 можно писать и использовать модули для
Python 2.7.0.  
6. С версии 1.1.0 методы `getDataDirPath()`, `getPluginDirPath()` и их алиасы возвращают не объекты Java-класса *Path*,
а обычные строки, что позволяет работать с ними, используя привычные для Python path-функции модуля *os*.  
7. Одними из самых часто требуемых возможностей для плагинов является хранение настроек и локализация строк под разные
языки. Поэтому начиная с *jython_support v1.1.0* можно использовать модуль **pluginutils**, который содержит классы
*Settings* и *Localization*. Подробнее о них в следующем подразделе.  

### Модули, предоставляемые плагинописателям

#### busproxy (с v1.0.2)

Позволяет импортировать функции для работы API в пространство плагина и обойтись без явного обращения к *шине*. Также
определяет для функций псевдонимы в нижнем регистре, чтобы представить их в более Pythonic-виде.  

С версии 1.1.2 изменился механизм инициализации модуля. Дальше в примерах кода приведён только новый вариант.  

Пример:  

```python
import busproxy
busproxy.init(globals())

add_message_listener("my_plugin:some_tag", lambda tag, sender, data: say(u"Привет!"))
```

#### pluginutils (с v1.1.0)

Предоставляет ряд полезных классов.  

##### Settings

Класс _Settings_ — это мультитон (на каждый плагин выделяется по отдельному синглтону), который при первой
инициализации считывает специальный файл в формате JSON из папки, выделенной под данные плагина, если он существует
(иначе получим пустой словарь). По умолчанию файл называется `settings.json`, но это имя может быть переопределено
при создании объекта при первом вызове метода `get_instance([имя файла])`.  
Дальше объект можно использовать, как обычный словарь:

```python
import busproxy
busproxy.init(globals(), "say", "log")
from pluginutils import Settings


opts = Settings.get_instance()

# Если значения нет, то вернётся None...
if opts['some_key']:
    say(opts['some_key'])
    # ...но можно воспользоваться специальным методом, чтобы получить какое-то другое значение:
    log(opts.get("another_key", "<no value>"))
else:
    opts['some_key'] = "some value"
    # Можно задавать сразу несколько значений, а сохранятся на диск они...
    opts.save()    # ...только после вызова этого метода.
    # Впрочем, для одного значения можно воспользоваться специальным методом, который сразу запишет данные на диск.
    opts.set("another_key", "another value")
```

##### Localization

Класс _Localization_ — это тоже мультитон, который считывает файл со строками для требуемого или доступного языка из
специального файла при первой инициализации с помощью метода `get_instance([путь до папки с файлами локализации])`.
При создании объекта (то есть при первом использовании этого метода) Вы должны указать ему путь до папки с файлами
локализации относительно папки плагина. При следующих использованиях метода этот параметр игнорируется, так что его
можно смело упускать.  

Файлы ожидаются в формате `xx_YY.txt`, где `xx` — это двухбуквенный код языка, а `YY` — код страны. Если файла,
соответствующего текущей локали в указанном формате нет, то ищется файл в формате `xx.txt`. Если же локализацию для
желаемого языка не получается найти, то используется файл `en.txt` (английский язык). Если же
нет и его, то выбрасывается исключение *IOError* с сообщением об отсутствующей локализации по умолчанию. Так что
предоставление строк для английского языка является обязательным!

Формат файлов локализации предельно прост: каждая строка — одна фраза в формате `ключ = значение`. Перед и после знака
равенства может быть большее количество пробелов или знаков табуляции — оформляйте, чтобы было удобно.  

Значения можно получить из экземпляра класса с помощью обычного синтаксиса словарей:  

```python
import busproxy
busproxy.init(globals(), "say")
from pluginutils import Localization


l10n = Localization.get_instance("localization")

# Если такой строки нет, то будет выкинуто ValueError с сообщением об отсутствующей строке локализации.
localized_string = l10n['hello_world']
say(localized_string)
```

### Немного насчёт версионирования

Когда я выпускал первую версию плагина, почему-то с детской наивностью полагал, что всё получилось вполне стабильно и
будет лишь изредка пополняться новыми методами и исправлениями. Как это было глупо! Я уже не раз пожалел, что начал
отсчёт версий с единицы, создав иллюзию стабильности. Соответственно, для меня теперь эта единица практически равноценна
нулю: пока не будет релиза самого DC и хотя бы нескольких разработок на Jython от сторонних авторов, тщательно отпинавших
меня за обнаруженные баги, то не будет версии 2.0.0.  

Теперь, когда мы разобрались, что принципы семантической вёрстки не соблюдаются, давайте разберёмся, что значат
остальные две цифры и как обнаружить breaking changes.  
Я стараюсь сохранять обратную совместимость, но это получается не всегда (например, никак нельзя было исправить
независимость шины в *busproxy* для разных плагинов, не изменив механизм инициализации). Но узнать по версии об этом не
получится. После окончательного релиза с версии 2.* я буду пользоваться семантическим версионированием и увеличивать
мажорную версию при изменениях, ломающих обратную совместимость. Сейчас же я не разделяю, что минорная версия — для
breaking changes, а патч-версия — для остальных. Нет. Поэтому внимательно читайте release notes к каждому релизу.  
Так как же я распоряжаюсь оставшимися цифрами? Всё просто. Я изменяю последнюю цифру, если изменений с предыдущей версии
было немного и они были направлены на исправление каких-либо ошибок или усовершенствование внутренней работы. Если же
добавляется какой-то новый модуль или вообще с выхода прошлой версии накопилось очень много изменений, но инкременирую
минорную версию. Вот и всё. Опять же, с версии 2.* они будут увеличиваться согласно общепринятым договорённостям.
