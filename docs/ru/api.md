# Документция для DeskChan API

Все взаимодействия между плагинами происходят
с помощью сообщений. Любое сообщение имеет тег
и данные (данные могут быть равны null, если они не нужны).

На каждое сообщение могут быть подписаны ноль или несколько
плагинов. Каждый подписанный на тег плагин получает
все сообщения, которые отправлены с этим тегом.

Если требуется выбор из нескольких альтернативных
реализаций (то есть сообщение должен получить один плагин,
а не все сразу), то рекомендуется использовать механизм
"альтернатив" (см. core:register-alternative).

Рекомендуется ограничиться следующими типами данных
для сообщения: String, Integer, Float, Double,
Map<String, Object>, List<Object>. При этом последние
два типа должны содержать только объекты вышеперечисленных
типов.

В редких случаях возможно применение других типов.

Это необходимо для того, чтобы любое сообщение могло
быть сериализовано и десериализовано в JSON.

Для экспериментов возможно использовать вкладку
Debug (Отладка) диалога настроек DeskChan. В верхнем
поле ввода можно указать тег сообщения, а в нижнем -
данные в формате JSON. При нажатии кнопки сообщение
будет отправлено от имени плагина gui.

## Уведомления от плагина core

### core-events:plugin-load

#### Данные (String)

    id плагина

#### Описание

Посылается ядром каждый раз, когда загружается новый
плагин.

Это не обычное сообщение. При подписке на него подписчику
сразу же будут присланы сообщения на каждый уже загруженный
плагин. Таким образом вы можете узнать начальный список
плагинов.

### core-events:plugin-unload

#### Данные: String

    id плагина

#### Описание

Посылается ядром каждый раз, когда выгружается какой-нибудь
плагин.

## Сообщения для плагина core

### core:quit

#### Данные: null

#### Описание

Инициирует завершение приложения. Все плагины будут
выгружены. Отменить завершение приложения штатными
средствами нельзя.

### core:register-alternative

#### Данные: Map<String, Object>

    srcTag: String
    dstTag: String
    priority: Integer

#### Описание

Регистрирует новую альтернативу dstTag для тега
srcTag с приоритетом priority. Плагин core подписывается
на srcTag. При поступлении сообщения оно будет
перенаправлено на srcTag (при этом отправитель останется
таким как был, а не изменится на core). Если существует
несколько альтернатив для srcTag, то будет выбрана та,
которая имеет наибольшее числовое значение приоритета.

Плагин core запоминает id плагина, который зарегистрировал
альтернативу. При его выгрузке все альтернативы, которые
он зарегистрировал, будут удалены.

### core:unregister-alternative

#### Данные: Map<String, Object>

    srcTag: String
    dstTag: String

#### Описание

Удаление альтернативы dstTag для тега srcTag. Альтернатива
будет удалена только если данное сообщение отправлено
тем же плагином, что и зарегистрировал данную альтернативу.

См. также: core:register-alternative.

### core:change-alternative-priority

#### Данные: Map<String, Object>

    srcTag: String
    dstTag: String
    priority: Integer

#### Описание

Изменяет числовое значение приоритета для альтернативы
dstTag для тега srcTag. Изменить приоритет альтернативы
может любой плагин, а не только тот, который её
зарегистрировал.

В нормальных условиях изменять приоритет альтернативы
следует только по запросу пользователя.

См. также: core:register-alternative

### core:query-alternatives-map

#### Данные: Map<String, Object>

    seq: Object (рекомендуется Integer)

#### Ответное сообщение: Map<String, Object>

    seq: Object
    map:  Map<String, Object>
        Ключи: srcTag
        Значения: Map<String, Object>
            tag: String (dstTag)
            priority: Integer
            plugin: String (id плагина)

#### Описание

Служит для запроса списка всех зарегистрированных
альтернатив. Полезно для предоставления пользователю
возможности настройки приоритетов.

Тег ответного сообщения соответствует идентификатору
плагина, пославшего запрос. seq в ответном сообщении
равен seq в запросе.

См. также: core:register-alternative

### core:get-plugin-data-dir

#### Данные: Map<String, Object>

    seq: Object (рекомендуется Integer)

#### Ответное сообщение: Map<String, Object>

    seq: Object
    path: String
    
#### Описание

Позволяет плагину получить путь к каталогу, который
ему рекомендуется использовать для сохранения
своих настроек.

Тег ответного сообщения соответствует идентификатору
плагина, пославшего запрос. seq в ответном сообщении
равен seq в запросе.

## Уведомления от плагина gui

### gui-events:character-left-click

Пользователь кликнул левой кнопкой мыши по персонажу

### gui-events:character-right-click

Пользователь кликнул правой кнопкой мыши по персонажу

### gui-events:character-middle-click

Пользователь кликнул средней кнопкой мыши по персонажу

### gui-events:character-double-click

Пользователь дважды кликнул по персонажу

### gui-events:balloon-left-click

Пользователь кликнул по сообщению левой кнопкой мыши

### gui-events:balloon-right-click

Пользователь кликнул по сообщению правой кнопкой мыши

### gui-events:balloon-middle-click

Пользователь кликнул по сообщению средней кнопкой мыши

### gui-events:balloon-double-click

Пользователь дважды кликнул по сообщению кнопкой мыши

## Сообщения плагину gui

### gui:say

#### Данные: Map<String, Object>

    text: String
    characterImage: String (опционально)
    timeout: Integer (опционально)

#### Описание

Вывести текстовое сообщение. При этом на время показа
сообщения может быть изменена картинка персонажа на
указанную (из скина, если текущий скин не содержит
данного изображения, будет использовано normal).

Сообщение будет закрыто по клику пользователя или
по таймауту (указывается в миллисекундах, нулевое
значение отключает автоматическое закрытие сообщения,
при отсутствии значения будет использоваться
значение по умолчанию, которое можно настраивать
пользователь).

При закрытии сообщения картинка персонажа изменится на
текущую.

Рекомендуется вместо прямого обращения к плагину gui
использовать альтернативу DeskChan:say.

### gui:set-image

#### Данные: String

    Название картинки

#### Описание

Изменить текущую картинку персонажа. Используется,
если никакое сообщение не отображается, либо текущее
сообщение не переопределяет картинку.

Если картинка с таким именем не содержится в текущем скине,
то используется normal.

### gui:change-skin

#### Данные: String или Path

    Путь к скину

#### Описание

Меняет текущий скин. Изменение будет сохранено
в настройках.

### gui:register-extra-action

#### Данные: Map<String, Object>

    name: String
    msgTag: String
    msgData: Object (опционально)

#### Описание

Регистрирует простое действие. Оно доступно через
контекстное меню персонажа. При выборе действия
будет послано сообщение с тегом msgTag и msgData
(null, если не указать).

Действия автоматически удавляются при выгрузке плагина,
который их зарегистрировал.

В будущем способ вызова простого действия пользователем
может быть изменён.

Рекомендуется не обращаться напрямую к плагину gui,
а использовать альтернативу
DeskChan:register-simple-action.

### gui:add-options-tab

#### Данные: Map<String, Object>

    name: String
    msgTag: String (опционально)
    controls: List<Map<String, Object>>
    
#### Описание

Создаёт вкладку настроек для плагина, отправившего
это сообщение (автоматически удаляется при его
выгрузке).

Если указан параметр msgTag, то на вкладку будет
добавлена кнопка "Сохранить", которая при нажатии
отправляет сообщение с указанным тегом и со значениями
элементов управления.

controls является списком элементов управления,
которые должны быть размещены на вкладке.

Каждый элемент управления имеет как минимум три параметра:

    type: String
    id: String (опционально)
    label: String (опционально)

type задаёт тип элемента управления (в зависимости от него
могут добавлять другие обязательные и опциональные
параметры), label позволяет разместить текстовую подпись
рядом с элементом управления. Если же у элемента задан id,
то при нажатии на кнопку сохранения, он будет добавлен
в Map, который будет отправлен в качестве данных
сообщения (при этом ключом будет id, а значением -
текущее значение элемента управления).

#### Доступные элементы управления

##### Label

    value: String

Самый простой элемент управления. Статичная надпись.

##### TextField

    value: String (опционально)

Однострочное текстовое поле.

##### Spinner

    value: Integer (опционально)
    min: Integer (опционально)
    max: Integer (опционально)
    step: Integer (опционально)

Поле ввода для числовых значений.

##### ComboBox

    values: List<String>
    value: Integer (опционально)

Поле выбора из фиксированного набора вариантов.
Значением поля является индекс выбранного элемента.

##### ListBox

    values: List<String>
    value: List<Integer>

Поле выбора из фиксированного набора вариантов.
При этом пользователь имеет возможность выбрать
несколько элементов сразу. Значением является
список индексов выбранных элементов.

##### Button

    value: String
    msgTag: String
    msgData: Object (опционально)

Кнопка. Посылает сообщение с тегом msgTag и данными
msgData при нажатии.

##### FileField

    value: String

Поле выбора файла.

## Groovy Plugin API

Рекомендуется писать плагины на языке программирования
Groovy. Плагином является каталог, содержащий файл
plugin.groovy. В этом же каталоге можно также
сохранить какие-либо статичные файлы, необходимые
плагину. Для хранения настроек и кеша следует
использовать другой каталог (см. core:get-plugin-data-dir).

Скрипт должен отправить все необходимые сообщения
и подписаться на все необходимые ему сообщения.

Помимо всех стандартных функций Java ему доступны следующие
функции DeskChan Plugin API:

    void sendMessage(String tag, Object data);
    void sendMessage(String tag, Object data, ResponseListener responseListener);
    void addMessageListener(String tag, MessageListener listener);
    void removeMessageListener(String tag, MessageListener listener);
    void addCleanupHandler(Runnable handler);

sendMessage позволяет отправить сообщение с тегом tag
и данными data. Версия с тремя аргументами
преобразует data в Map, если он им не является
(при этом прошлое значение data будет сохранено
с ключом "data"). В этот словарь будет добавлено
числовое поле seq, которое будет монотонно возврастать
с каждым вызовом данной функции (то есть его можно
считать уникальным первые несколько миллиардов
вызовов sendMessage). В качестве последнего аргумента
можно передать лямбда-функцию, которая будет вызвана,
когда будет получен ответ с тем же seq и с тегом
соответствующим id текущего плагина. Лямбда-функция
должна принимать два аргумента: sender (String) и
data (Object).

addMessageListener и removeMessageListener соответственно
добавляют и удаляют подписку на сообщение
с указанным тегом (плагин может подписываться несколько
раз на одно и то же сообщения разными слушателями).
Слушателем может выступать лямбда-функция, принимающая
три аргумента: sender (String), tag (String), data (Object).
Можно использовать одного и того же слушателя для
разных сообщений (различать их по аргументу tag, если
требуется). При выгрузке плагина все его слушатели
удаляются автоматически.

addCleanupHandler позволяет зарегистрировать обработчик
выгрузки плагина. Он должен уничтожить те объекты, которые
в ином случае уничтожены не будут. В качестве него может
выступать лямбда-функция без аргументов.

## Python (Jython) Plugin API  

_Данное API не является стандартным, запилено другим человеком и может быть изменено в будущем._  

По сути тут всё аналогично вышеописанному Groovy Plugin API. Обратить внимание нужно на буквально несколько моментов:  

1. В отличие от Groovy-плагинов, Jython-плагины не являются наследниками никаких классов и,
соответственно, не имеют встроенных методов `sendMessage()`, `addMessageListener()` и т. п.
Но в исполяемую среду "инжектится" специальный объект — так называемая *шина* (**bus**) — с помощью
которой плагин "общается" с приложением. Она предоставляет ему описанные в предыдущем разделе методы.  
С версии 1.0.2 плагина *jython_support* для вызова API можно использовать модуль **busproxy**, который не только
позволяет импортировать функции в среду исполнения, но и предоставляет их псевдонимы в более Pythonic-виде
(`send_message()`, `add_message_listener()` и т. д.).  
2. Типы данных на ходу преобразуются между типами одного языка в другой. В случае каких-либо проблем
стоит иметь это в виду. Для примера использования API смотрите приложенный плагин-пример (*test_python*).  
3. Необходимые Вам зависимости (также с версии 1.0.2) можно ставить, используя *pip*, в папку `__dependencies__` внутри
проекта Вашего плагина. Она автоматически добавляется в путь поиска модулей.  
Устанавливать зависимости можно, например, следующей командой:  
`pip install --target=__dependencies__ --ignore-installed <названия пакетов...>`  
4. С версии 1.0.1 для *шины* (а с версии 1.0.2 он есть и в модуле *busproxy*) добавлен нестандартный метод `say()` для
облегчения вывода сообщений. Он автоматически преобразует строку в правильную кодировку и отправит сообщение GUI-плагину
на отображение сообщения. Поэтому при работе с символами, не входящими в таблицу ASCII, строго рекомендуется
использовать именно его! Также не забывайте указывать `u"юникодную природу строки"`!  
С версии 1.1.0 полностью поддерживаются все параметры `gui:say` (priority, timeout...). Для *шины* они указываются
вторым параметром в виде словаря, а для функции из модуля *busproxy* используются keywords-аргументы.  
5. Сначала плагин поддерживал интерпретацию только Python 2.5, но с версии 1.0.2 можно писать и использовать модули для
Python 2.7.0.  
6. С версии 1.1.0 методы `getDataDirPath()`, `getPluginDirPath()` и их алиасы возвращают не объекты Java-класса *Path*,
а обычные строки, что позволяет работать с ними, используя привычные для Python path-функции модуля *os*.  
7. Одними из самых часто требуемых возможностей для плагинов является хранение настроек и локализация строк под разные
языки. Поэтому начиная с *jython_support v1.1.0* можно использовать модуль **pluginutils**, который содержит классы
*Settings* и *Localization*. Подробнее о них в следующем подразделе.  

### Модули, предоставляемые плагинописателям

#### busproxy (с v1.0.2)

Позволяет импортировать функции для работы API в пространство плагина и обойтись без явного обращения к *шине*. Также
определяет для функций псевдонимы в нижнем регистре, чтобы представить их в более Pythonic-виде.  

Пример:  

```python
from busproxy import *

add_message_listener("my_plugin:some_tag", lambda tag, sender, data: say(u"Привет!"))
```

#### pluginutils (с v1.1.0)

Предоставляет ряд полезных классов.  

##### Settings

Класс _Settings_ — это мультитон (на каждый плагин выделяется по отдельному синглтону), который при первой
инициализации считывает специальный файл в формате JSON из папки, выделенной под данные плагина, если он существует
(иначе получим пустой словарь). По умолчанию файл называется `settings.json`, но это имя может быть переопределено
при создании объекта при первом вызове метода `get_instance([имя файла])`.  
Дальше объект можно использовать, как обычный словарь:

```python
from busproxy import say
from pluginutils import Settings


opts = Settings.get_instance()

if opts['some_key']:
    say(opts['some_key'])
else:
    opts['some_key'] = "some value"
    # Можно задавать сразу несколько значений, а сохранятся на диск они...
    opts.save()    # ...только после вызова этого метода.
    # Впрочем, для одного значения можно воспользоваться специальным методом, который сразу запишет данные на диск.
    opts.set("another_key", "another value")
```

##### Localization

Класс _Localization_ — это тоже мультитон, который считывает файл со строками для требуемого или доступного языка из
специального файла при первой инициализации с помощью метода `get_instance([путь до папки с файлами локализации])`.
При создании объекта (то есть при первом использовании этого метода) Вы должны указать ему путь до папки с файлами
локализации относительно папки плагина. При следующих использованиях метода этот параметр игнорируется, так что его
можно смело упускать.  

Файлы ожидаются в формате `xx_YY.txt`, где `xx` — это двухбуквенный код языка, а `YY` — код страны. Если файла,
соответствующего текущей локали в указанном формате нет, то ищется файл в формате `xx.txt`. Если же локализацию для
желаемого языка не получается найти, то используется файл `en.txt` (английский язык). Если же
нет и его, то выбрасывается исключение *IOError* с сообщением об отсутствующей локализации по умолчанию. Так что
предоставление строк для английского языка является обязательным!

Формат файлов локализации предельно прост: каждая строка — одна фраза в формате `ключ = значение`. Перед и после знака
равенства может быть большее количество пробелов или знаков табуляции — оформляйте, чтобы было удобно.  

Значения можно получить из экземпляра класса с помощью обычного синтаксиса словарей:  

```python
from busproxy import say
from pluginutils import Localization


l10n = Localization.get_instance("localization")

# Если такой строки нет, то будет выкинуто ValueError с сообщением об отсутствующей строке локализации.
localized_string = l10n['hello_world']
say(localized_string)
```
